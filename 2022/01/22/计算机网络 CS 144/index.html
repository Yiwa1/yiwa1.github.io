

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/Betterfavicon.png">
  <link rel="icon" href="/img/Betterfavicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yi wa">
  <meta name="keywords" content="Java,Linux,Software">
  
    <meta name="description" content="Computer Network CS 144Related terms bi-directional byte stream（双向字节流） TCP （传输控制协议） http （超文本传输协议） Network Address translation（网络地址转换） rendezvous rely servers（集合中继服务器）  1-1 Network Application HTTP（超文">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络-CS144">
<meta property="og:url" content="http://blog.yiwa.ga/2022/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20CS%20144/index.html">
<meta property="og:site_name" content="Yiwa">
<meta property="og:description" content="Computer Network CS 144Related terms bi-directional byte stream（双向字节流） TCP （传输控制协议） http （超文本传输协议） Network Address translation（网络地址转换） rendezvous rely servers（集合中继服务器）  1-1 Network Application HTTP（超文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/HTTPsimpleModel.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/SkypeWithComplication.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/SkypeWithMoreComplication.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/202109252117571.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/202109252251820.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/202109252305791.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/202109252308033.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/DataHeader.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/IPServiceProperties.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/IPDAandIPSA.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/ReasonsIPSimple.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/IPServiceDetails.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/IPV4Datagram.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/threeHandShake.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/TCPport.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/RouterFunction.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/forwardingtable.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/SwitchAndFlow.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/EfficientSharingOfLinks.png">
<meta property="article:published_time" content="2022-01-22T09:48:10.000Z">
<meta property="article:modified_time" content="2022-01-22T11:18:12.626Z">
<meta property="article:author" content="Yi wa">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/HTTPsimpleModel.png">
  
  
  <title>计算机网络-CS144 - Yiwa</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"blog.yiwa.ga","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"lcobS6qdM7WhWNh8XGijI5Qt-MdYXbMMI","app_key":"8HTyOUX9t6NOaUdy2OuVJPWm","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yiwa&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/blue-snow.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.2)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="计算机网络-CS144">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-22 17:48" pubdate>
        2022年1月22日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      156 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计算机网络-CS144</h1>
            
            <div class="markdown-body">
              <h2 id="Computer-Network-CS-144"><a href="#Computer-Network-CS-144" class="headerlink" title="Computer Network CS 144"></a>Computer Network CS 144</h2><h3 id="Related-terms"><a href="#Related-terms" class="headerlink" title="Related terms"></a>Related terms</h3><ol>
<li>bi-directional byte stream（双向字节流）</li>
<li>TCP （传输控制协议）</li>
<li>http （超文本传输协议）</li>
<li>Network Address translation（网络地址转换）</li>
<li>rendezvous rely servers（集合中继服务器）</li>
</ol>
<h3 id="1-1-Network-Application"><a href="#1-1-Network-Application" class="headerlink" title="1-1 Network Application"></a>1-1 Network Application</h3><blockquote>
<p>HTTP（超文本传输协议</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/HTTPsimpleModel.png" srcset="/img/loading.gif" lazyload width="100%" style="margin-left:10%"  />

  

  


<p>basic model： ==client sends a request by writing to the connection, the server reads the request, processes it, and writes a response to the connection, which the  client then reads.==</p>
<blockquote>
<p>Bit Torrent</p>
</blockquote>
<p><em><strong>What is bit torrent?</strong></em> </p>
<p><em><strong><u>==Bit Torrent== is a program that allows people to share and exchange large files. In Bit Torrent a client requests documents from other clients. Bit Torrent breaks files up into chunks of data called pieces.  When a client downloads a complete piece from another client, it then tells other clients it has that piece so they can download it  too. These collections of collaborating clients are called swarms.</u></strong></em>  </p>
<p>simple model:==. When a client wants to download a file, it first has to find something called a torrent file. Usually, you find this using the world wide web and download it using, you guessed it, HTTP. This torrent file describes some information about  the data file you want to download. It also tells Bit Torrent about who the tracker is for that torrent. A tracker is a node that  keeps track (hence the name) of what clients are members of the swarm. To join a torrent, your client contacts the tracker, again, over HTTP, to request a list of other clients. Your client opens connections to some of these clients and starts requesting  pieces of the file. Those clients, in turn, can request pieces. Furthermore, when a new client joins the swarm, it might tell this  new client to connect to your client. So rather than a single connection between a client and one server, you have a dense graph  of connections between clients, dynamically exchanging data.== </p>
<blockquote>
<p>Skype</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/SkypeWithComplication.png" srcset="/img/loading.gif" lazyload width="100%" style="margin-left:10%" />  



  





<p>==NAT==: <em><strong><u>if you’re  behind a NAT then you can open connections out to the Internet, but other nodes on the Internet can’t  easily open connections to you.</u></strong></em>  </p>
<p>simple mode:==It does so using something called a rendezvous server. When you log into Skype, your client opens connections to a network of control servers. In this case,  client B opens a connection to the rendezvous server. This works fine because the server isn’t behind a NAT and client B can open connections out without any  problems. When client A calls client B, it sends a message to the rendezvous server. Since the server has an open connection to client B, it tells B that there’s a call  request from A. The call dialog pops up on client B. If client B accepts the call, then it opens a connection to client A. Client A was trying to open a connection  to client B, but since B was behind a NAT, it couldn’t. So instead it sends a message to a computer that client B is already connected to, which then asks client  B to open a connection back to client A. Since client A isn’t behind a NAT, this connection can open normally. This is called a reverse connection because it  reverses the expected direction for initiating the connection. Client A is trying to connect to client B, but instead client B opens a connection to client A.==  </p>
<img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/SkypeWithMoreComplication.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" /> 

  



<p>simple model: ==Skype introduces a second kind of server, called a relay. Relays can’t be behind NATs. If both client A and client B are behind NATs, then the communicate through a  relay. They both open connections to the relay. When client A sends data, the relay forwards  it to client B through the connection that B opened. Similarly, when client B sends data, the  relay forwards it to client A through the connection client A opened.==</p>
<h3 id="1-2-Layer-Internet-Model"><a href="#1-2-Layer-Internet-Model" class="headerlink" title="1-2 Layer Internet Model"></a>1-2 Layer Internet Model</h3><img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/202109252117571.png" srcset="/img/loading.gif" lazyload style="margin-left=10%" width="100%" /> 

  



<blockquote>
<p>Link Layer</p>
</blockquote>
<p>The Internet is made up of en1d hosts, links and routers. Data is delivered hop-by-hop over each  link in turn. Data is delivered in packets. A packet consists of the data we want to be delivered,  along with a header that tells the network where the packet is to be delivered, where it came  from and so on.</p>
<p>==Link Layer==: <u>The Link Layer’s job is to carry the data over one link at a time.__</u></p>
<p>Example: Ethernet,WiFi and 5G</p>
<blockquote>
<p>Network Layer</p>
</blockquote>
<p>packets: </p>
<table>
<thead>
<tr>
<th>==data==</th>
<th align="left">==header== contains “to” and from “address”</th>
</tr>
</thead>
</table>
<p>==Network Layer==:<u>The network layer’s job is to deliver packets end-to-end across the Internet from the source to the destination.</u></p>
<p>The Network hands the datagram to the Link Layer below, telling it to send the datagram over the first link. In other words, the Link Layer is providing a <em>service</em> to the Network Layer. Essentially, the Link Layer says: “if you give me a datagram to send, I will transmit it over one link for you.  </p>
<p>At the other end of the link is a router. The Link Layer of the router accepts the datagram from the link, and hands it up to the Network Layer in the router. The Network Layer on the router examines the destination address of the datagram, and is responsible for routing the datagram one hop at a time towards its eventual destination.  It does this by sending to the  Link Layer again, to carry it  over the next link. And so on until it reaches the Network Layer at the destination.  </p>
<p>==We Must Use Internet Protocal(IP)==</p>
<p>In the internet, the network layer is special: When we send packets into the Internet, we must use the Internet Protocol. It is the Internet Protocol, or IP, that holds the Internet together</p>
<ul>
<li><p>IP makes a best-effort attempt to deliver our datagrams to the other end. But it makes no promises</p>
</li>
<li><p>IP datagrams can get lost, can be delivered out of order, and can be corrupted. There are no guarantees.  </p>
</li>
</ul>
<blockquote>
<p>Transport</p>
</blockquote>
<p>The most common Transport Layer is TCP. TCP makes sure that data sent by an application at one end of the Internet is correctly delivered – in the right order to the application at the other end of the Internet. If the  Network Layers drops some datagrams, TCP will retransmit  them, multiple times if need-be.  </p>
<p>Example: TCP UDP</p>
<blockquote>
<p>Application</p>
</blockquote>
<p>There are of course many thousands  f applications that use the  Internet. While each application is different, it can reuse the Transport Layer by using the well-defined API from the Application Layer to the TCP or UDP service beneath.  </p>
<p>==How it works==</p>
<img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/202109252251820.png" srcset="/img/loading.gif" lazyload style="margin-left=10%" width="100%" />   

  

  



<p>When a web client requests a page from a web server, the web client sends a GET request. This is one of the commands of the hypertext transfer protocol, or http. http dictates that the GET command is sent as an ASCII  string, along with the URL of the page being requested. As far as the Application Layer is concerned, the GET request is sent directly to its peer at the other end – the web server Application . The Application  doesn’t need to know how it got there, or how many times it  needed to be retransmitted. At the web client, the Application  Layer hands the GET request to the TCP layer, which provides the service of making sure it is  reliably delivered. It does this using the services of the  Network layer which has the job of breaking the data into packets, each with the correct destination address and in turn uses the services of the Link Layer.  </p>
<h4 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h4><img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/202109252305791.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" />

  







<img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/202109252308033.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" />  

  

  

<h4 id="7-layer-OSI-Model"><a href="#7-layer-OSI-Model" class="headerlink" title="7-layer OSI Model"></a>7-layer OSI Model</h4><h3 id="1-3-IP-service"><a href="#1-3-IP-service" class="headerlink" title="1-3 IP service"></a>1-3 IP service</h3><img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/DataHeader.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" />

  

  

<p>IP datagrams consist of a header and some data. When the transport layer has data to send, it hands a Transport Segment to the Network layer below.   The network layer puts the transport segement inside a  new IP datagram. IP’s job is to deliver the datagram to the other end. But first, the IP datagram has to make it over the first link to the first router. IP sends the datagram to the Link Layer that puts it inside a Link frame, such as an Ethernet packet and ships it off to the first router.  </p>
<h4 id="IP-Property"><a href="#IP-Property" class="headerlink" title="IP Property"></a>IP Property</h4><img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/IPServiceProperties.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" /> 

  



<p>The IP service can be characterized by four properties listed here. It sends Datagrams from end host to end host; it is unreliable, but makes a best-effort to deliver the datagrams. The network maintains no per-flow state associated with the datagrams.</p>
<p>==properties==</p>
<ol>
<li>The IP service model provides a service which includes the routing to the destination. </li>
<li>IP is unreliable. IP makes no promise that packets will be delivered to the destination. They could be delivered late, out of sequence, or never delivered at all. It’s possible that a packet will be duplicated along the way, for example by a misbehaving router. The key thing to remember is that IP is unreliable and makes no guarantees.</li>
<li>It won’t drop datagrams arbitrarily just because it feels like it.</li>
<li>IP is an extremely simple, minimal service. It maintains no state at all related to a  communication. We say that a communication service is “connectionless” because it doesn’t start by establishing some end to state associated with the communication. In other words, when we  make a Skype call lasting several minutes and consisting of many IP datagrams, the IP layer maintains no knowledge of the call, and simply routes each datagram individually and independently of all the others.  </li>
</ol>
<h4 id="IP-Header"><a href="#IP-Header" class="headerlink" title="IP Header"></a>IP Header</h4><img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/IPDAandIPSA.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" />  

  



<p>The header contains the IP address of the destination, which we abbreviate here as “IP  DA” for IP destination address. The forwarding decision at each router is based on the IP DA. The datagram header also contains an IP source address, or “IP SA”, saying where the packet came from, so the receiver knows where to send any response.  </p>
<blockquote>
<p>forwarding table</p>
</blockquote>
<p>each router contains a forwarding table that tells it where to send packets matching a given destination address. The router doesn’t know the whole path – it simply uses the  destination address to index into its forwarding table so that  it can forward the packet to the next hop along the path  towards its final destination. Hop by hop, step by step the  packet makes its way from the source to the destination  using only the destination address in the datagram.  </p>
<h4 id="Reasons-Why-IP-is-simple"><a href="#Reasons-Why-IP-is-simple" class="headerlink" title="Reasons Why IP is simple"></a>Reasons Why IP is simple</h4><img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/ReasonsIPSimple.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" />  

<p>​    </p>
<ol>
<li>==To keep the network simple, dumb and minimal. Faster, more streamlined and lower cost to build and maintain.== It was believed that if the network is kept simple with very features and requirements, then packets could be delivered very quickly, and at low cost. The thinking was that a simple network could be made to run very fast using dedicated hardware. And given that the  network is implemented by a large number of routers  scattered throughout the network, if they could be kept simple then are likely to be more reliable, more affordable to maintain and will need to be upgraded less often.</li>
<li>==The end to end principle: Where possible, implement features in the end hosts.==The basic idea is to place as much intelligence as possible at the end points.This can have several advantages, such as making sure the feature is implemented correctly for the application, and it is easier to evolve and improve a feature if it is implemented in software on end computers rather than  baked into the hardware of the Internet. </li>
<li>==Allows a variety of reliable (or unreliable) services to be built on top.== If IP was reliable – in other words if any missing packets were retransmitted  automatically – then it would not be ideal for some services. For example, in real time applications like a video chat, there might be no point in retransmitting lost data, because it might arrive too late to be useful. Instead, the application might choose to show a few blank pixels or use the pixels from the frame before. By  not providing any reliability guarantees, IP lets the application choose the reliability service its needs.</li>
<li>==Works over any link layer: IP makes very few assumptions about the link layer.== IP makes very little expectation of the Link layer below – the link could be wired  r wireless, and requires no retransmission or control of congestion.  </li>
</ol>
<h4 id="other-IP-service"><a href="#other-IP-service" class="headerlink" title="other IP service"></a>other IP service</h4><img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/IPServiceDetails.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" />  

  




<ol>
<li>==IP tries to prevent packets from looping forever.== This is most likely to happen when the forwarding tables are changing and they temporarily get into an inconsistent state. Rather than try to prevent loops from ever happening – which would take a lot of complexity - IP uses a very simple mechanism to catch and then delete packets that appear to be stuck in a loop. To do this, IP simply adds a hop-count field in the header of every datagram. It is called the time to live, or TTL field. It starts out at a number like 128 and then is decremented by every router it passes through. If it reaches zero, IP  concludes that it must be stuck in a loop and the router drops the datagram. </li>
<li>==IP will fragment packets if they are too long.== IP provides some header fields that we will see in a minute to help the router fragment the datagram into two self-contained IP datagrams, while providing the information the end host needs to correctly reassemble the data again.</li>
<li>==IP uses a header checksum to reduce chances of delivering a datagram to the wrong destination.==IP includes a checksum field in the datagram header to try and make sure datagrams are delivered to the right location.</li>
<li>==Allows for new versions of IP.== There are two versions of IP in use today: IPv4, which is used today by over 90% of end hosts. It uses the 32bit addresses you are probably familiar with. Because we are running out of IPv4 addresses, the Internet is in a gradual transition to IPv6, which uses 128 bit addresses instead.</li>
<li>==IP allows new fields to be added to the datagram header.== This is a mixed blessing. On the one hand, it allows new features to be added to the header that turn out  to be important, but weren’t in the original standard. On the other hand, these fields need processing and so require extra features in the routers along the path, breaking the goal of a simple, dumb, minimal forwarding path. In practice, very few options are used or processed by the routers.</li>
</ol>
<h4 id="IPV4-Datagram"><a href="#IPV4-Datagram" class="headerlink" title="IPV4 Datagram"></a>IPV4 Datagram</h4><img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/IPV4Datagram.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" />  

  





<ol>
<li> The ==Protocol ID==, that tells us what is inside the data field. Essentially, it allows the destination end host to demultiplex arriving packets, sending them to the correct code to process the packet. If the Protocol ID has the value  “6” then it tells us the data contains a TCP Segment, and so  we can safely pass the datagram to the TCP code and it will be able to parse the segment correctly. The Internet Assigned Numbers Authority (IANA) defines over 140  different values of Protocol ID, representing different  transport protocols.</li>
<li>The ==Version== tells us which version of IP – currently, the legal values are IPv4 and IPv6.</li>
<li>The ==Total packet length== can be up 64kBytes  including the header and all the data.</li>
<li>The ==Time to Live== field helps us to prevent packets accidentally looping in the network forever. </li>
<li>Sometimes a packet is too long for the link it is  bout to be sent on. The ==Packet ID, Flags and Fragment Offset== all help routers to fragment IP packets into smaller self-contained packets if need-be.</li>
<li>The ==Type of Service== field gives a hint to routers about how important this packet is.</li>
<li>The ==Header Length== tells us how big the header is — some headers have optional extra fields to carry extra information.</li>
<li>a ==checksum== is calculated over the whole header so just in case the header is corrupted, we are not likely to deliver a packet to the wrong desination by mistake.</li>
</ol>
<h3 id="1-4Life-of-Packet"><a href="#1-4Life-of-Packet" class="headerlink" title="1-4Life of Packet"></a>1-4Life of Packet</h3><h4 id="three-way-handshack"><a href="#three-way-handshack" class="headerlink" title="three way handshack"></a>three way handshack</h4><img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/threeHandShake.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" />  

  



<p>==The first step of handshake is when the client sends a “synchronize” message to the server, often  called a SYN. The second step is when the server responds with a “synchronize” message that also  acknowledges the clients “synchronize”, or a “synchronize and acknowledge message”, often called  a SYN-ACK. The third and final step is when the client responds by acknowledging the server’s  synchronize, often called an ACK. So often the three way handshake is described as “synchronize,  synchronize and acknowledge, acknowledge”, or “SYN, SYN-ACK, ACK”.==</p>
<img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/TCPport.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%"/>  

  

  




<p>==TCP port==</p>
<p>Recall that the ==network layer is responsible for delivering packets to computers==, but the ==transport  layer is responsible for delivering data to applications==. From the perspective of the network layer,  packets sent to different applications on the same computer look the same. This means that to open  a TCP stream to another program, we need two addresses. The first, an ==Internet Protocol address,is the address the network layer uses to deliver packets to the computer==. The second, ==the TCP port,  tells the computer’s software which application to deliver data to==. Web servers usually run on TCP  port 80. So when we open a connection to a web server, we send IP packets to the computer running the web server whose destination address is that computer’s IP address. Those IP packets have TCP segments whose destination port is 80.</p>
<p>==router==</p>
<img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/RouterFunction.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" />  

<p>​    </p>
<p>But how do those IP packets get to their destination? We don’t have a direct wire connecting my  client to the server. Instead, my client is connected to an intermediate computer, a router. This router is itself connected to other routers. IP packets between the client and server take many “hops,”  where ==a hop is a link connecting two routers==. For example, since my client is on a WiFi network, the first hop is wireless to the WiFi access point. The access point has a wired connection to the broader Internet, so it forwards my client’s packets along this wired hop. A router can have many links connecting it. As each packet arrives, a router decides which of its links to send it out on. Routers have IP addresses, so it’s also the case that it might not forward a  packet but rather deliver it to its own software. For example, when you log into a router using TCP,  the IP packets are destined to the router’s own IP address</p>
<p>==forwarding table==</p>
<img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/forwardingtable.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" />  

  

  

 




<p>A ==forwarding table== consists of a set of IP address patterns and the link to send across for each pattern</p>
<p>When a packet arrives, the router checks which forwarding table entry’s pattern best matches the  packet. It forwards the packet along that entry’s link. Generally, “best” means the most specific  match. The default route is the least specific route. It matches every IP address. If,when a packet arrives, there isn’t a more specific route than the default route, the router will just use the default one.</p>
<h3 id="1-5-packect-switching"><a href="#1-5-packect-switching" class="headerlink" title="1-5 packect switching"></a>1-5 packect switching</h3><p>==packet switching==</p>
<p>Independently for each arriving packet, pick its outgoing link. If the link is free,send it. Else hold the packet for latter.</p>
<p>Packet switching is the idea that we break our data up into discrete, self-contained chunks of data. Each chunk, called a packet, carries sufficient information that a network can deliver the packet to its destination. So let’s say we have a source and a destination, and a network of packet switches  A, B, and C between them. When A receives a packet for the destination, it sends it along the link to B. When B receives a  packet for the destination, it sends it along to C. When C  receives a packet for the destination, it sends it to the  destination. In the simplest form of packet switching, each packet is routed separately and independently. For example,  let’s say there’s another switch connected to B, called D.  Immediately after sending a packet to C, B can send the next packet to D. Or, if the next packet were also to the  destination, it would send two packets back-to-back to C.</p>
<p>Here’s one example of how packet switching can work: each packet contains an explicit route, specifying the IDs of each packet switch along the way. We call this “self routing” or “source routing,” because the source specifies the route. When the source sends a packet, it puts in the packet A, B, C,destination. It then forwards the packet to A. A looks  inside the header and sees the next hop is B. So it forwards the packet to B. B sees the next hop is C, and C sees the last  hop is the destination. It turns out the Internet supports  source routing, but it’s generally turned off because it raises big security issues. People owning routers don’t want you telling them how to send packets, because maybe you can trick them to sending them somewhere they shouldn’t, such  as secure computers.</p>
<p>One simple optimization, and what the Internet mostly does today, is to place a small amount of state in each switch which tells it which next hop to send packets to.</p>
<p>==packet switch type==</p>
<p>In the Internet there are several different types of packet switches. Some of them are called routers or gateways, while others are called Ethernet switches. </p>
<p>==packet switching properties==</p>
<p>Packet switching has two really nice properties. The first is that a switch can make individual, local decisions for each  packet. It doesn’t need to keep extra state on the packets its seen or whether two packets go to the same destination.  Even if many packets are part of some larger transfer or protocol, the switch doesn’t need to know or care. The switch doesn’t need to know that some packets are a Skype  call, others are a web request, and others still are a  firmware update for your computer. It just forwards packets. This greatly simplifies the switch.</p>
<p>The second is that it lets a switch efficiently share a link between many parties. For example, consider a wireless router in a home with two people browsing the Internet on their laptops. If one person is reading a page,  then the other person can download a file at the full speed  of the link. If the first person starts loading a new web page,  the link can be shared between the two of them. Once the download completes, the first person can use the full speed of the link.</p>
<img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/SwitchAndFlow.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" />  

  

   




<p>Because each packet is self-contained, ==a switch doesn’t need to know about groups of packets, or flows of packets.== Imagine if every switch had to keep track of every single web connection passing through it. This would require a huge amount of state that would be hard to manage! Instead, treating each packet independently means the switch can be much simpler to build, manage, and  troubleshoot. </p>
<p>==The switch doesn’t need to worry about adding or removing this per-flow state.== Imagine if every time you wanted to load a web page, you had to communicate with every switch along the path to set up state so your request would work. This could make things much slower. Instead, you can just send packets and the switches forward them appropriately. </p>
<p>==The switches also don’t need to <em>store</em> this state.== Because switches have to be fast, they’d need to store this state in very fast memory, which is expensive. This lets switches focus on doing one thing, forwarding packets quickly. </p>
<p>Finally,==it means switches don’t have to worry about failures.== Imagine, for example, what happens when you start a web request but then your tablet runs out of energy. The switch is going to keep the per-flow state for the request, but if one of the nodes that created the state fails, the switch needs to know how to clean up after it. Otherwise you can have millions, billions of dead flows eating up your memory. With packet switching, a switch has no per-endpoint state. If your tablet dies, the switch doesn’t care, it just means that it stops receiving packets from it. In this way the switch is more functionally independent of the computers sending traffic through it.</p>
<img src="https://cdn.jsdelivr.net/gh/Yiwa1/Picture-bed/note/ComputerNetwork/EfficientSharingOfLinks.png" srcset="/img/loading.gif" lazyload style="margin-left:10%" width="100%" />  

  






























            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"lcobS6qdM7WhWNh8XGijI5Qt-MdYXbMMI","appKey":"8HTyOUX9t6NOaUdy2OuVJPWm","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="http://www.blog.yiwa.ga" target="_blank" rel="nofollow noopener"><span>Yiwa</span></a> <i class="iconfont icon-love"></i> <a href="#" target="_blank" rel="nofollow noopener"><span>Everything</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
